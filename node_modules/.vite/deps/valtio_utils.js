import {
  getVersion,
  proxy,
  ref,
  snapshot,
  subscribe,
  unstable_buildProxyFunction,
  useSnapshot
} from "./chunk-PZ52HLVL.js";
import {
  require_react
} from "./chunk-4HAMFFQC.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/derive-valtio/dist/index.modern.js
var o = /* @__PURE__ */ new WeakMap();
var r = /* @__PURE__ */ new WeakMap();
var s = (e, t) => {
  const n = o.get(e);
  n && (n[0].forEach((t2) => {
    const { d: n2 } = t2;
    e !== n2 && s(n2);
  }), ++n[2], t && n[3].add(t));
};
var l = (e) => {
  const t = o.get(e);
  t && (--t[2], t[2] || (t[3].forEach((e2) => e2()), t[3].clear()), t[0].forEach((t2) => {
    const { d: n } = t2;
    e !== n && l(n);
  }));
};
var c = (e) => {
  const { s: n, d: c2 } = e;
  let a2 = r.get(c2);
  a2 || (a2 = [/* @__PURE__ */ new Set()], r.set(e.d, a2)), a2[0].add(e);
  let d2 = o.get(n);
  if (!d2) {
    const e2 = /* @__PURE__ */ new Set(), r2 = subscribe(n, (t) => {
      e2.forEach((e3) => {
        const { d: o2, c: r3, n: c3, i: a3 } = e3;
        n === o2 && t.every((e4) => 1 === e4[1].length && a3.includes(e4[1][0])) || e3.p || (s(n, r3), c3 ? l(n) : e3.p = Promise.resolve().then(() => {
          delete e3.p, l(n);
        }));
      });
    }, true);
    d2 = [e2, r2, 0, /* @__PURE__ */ new Set()], o.set(n, d2);
  }
  d2[0].add(e);
};
var a = (e) => {
  const { s: t, d: n } = e, s2 = r.get(n);
  null == s2 || s2[0].delete(e), 0 === (null == s2 ? void 0 : s2[0].size) && r.delete(n);
  const l2 = o.get(t);
  if (l2) {
    const [n2, r2] = l2;
    n2.delete(e), n2.size || (r2(), o.delete(t));
  }
};
var d = (e) => {
  const t = r.get(e);
  return t ? Array.from(t[0]) : [];
};
var i = { add: c, remove: a, list: d };
function f(t, r2) {
  const s2 = (null == r2 ? void 0 : r2.proxy) || proxy({}), l2 = !(null == r2 || !r2.sync), d2 = Object.keys(t);
  return d2.forEach((e) => {
    if (Object.getOwnPropertyDescriptor(s2, e)) throw new Error("object property already defined");
    const r3 = t[e];
    let i2 = null;
    const f2 = () => {
      if (i2) {
        if (Array.from(i2).map(([e2]) => ((e3, t3) => {
          const n = o.get(e3);
          return !(null == n || !n[2] || (n[3].add(t3), 0));
        })(e2, f2)).some((e2) => e2)) return;
        if (Array.from(i2).every(([e2, t3]) => getVersion(e2) === t3.v)) return;
      }
      const t2 = /* @__PURE__ */ new Map(), u2 = r3((e2) => (t2.set(e2, { v: getVersion(e2) }), e2)), p = () => {
        var n;
        t2.forEach((t3, n2) => {
          var o2;
          const r4 = null == (o2 = i2) || null == (o2 = o2.get(n2)) ? void 0 : o2.s;
          if (r4) t3.s = r4;
          else {
            const o3 = { s: n2, d: s2, k: e, c: f2, n: l2, i: d2 };
            c(o3), t3.s = o3;
          }
        }), null == (n = i2) || n.forEach((e2, n2) => {
          !t2.has(n2) && e2.s && a(e2.s);
        }), i2 = t2;
      };
      u2 instanceof Promise ? u2.finally(p) : p(), s2[e] = u2;
    };
    f2();
  }), s2;
}
function u(e, t) {
  const n = null != t && t.delete ? /* @__PURE__ */ new Set() : null;
  d(e).forEach((e2) => {
    const { k: o2 } = e2;
    null != t && t.keys && !t.keys.includes(o2) || (a(e2), n && n.add(o2));
  }), n && n.forEach((t2) => {
    delete e[t2];
  });
}

// node_modules/valtio/esm/vanilla/utils.mjs
function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
var currentCleanups;
function watch(callback, options) {
  let alive = true;
  const cleanups = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new Map();
  const cleanup = () => {
    if (alive) {
      alive = false;
      cleanups.forEach((clean) => clean());
      cleanups.clear();
      subscriptions.forEach((unsubscribe) => unsubscribe());
      subscriptions.clear();
    }
  };
  const revalidate = async () => {
    if (!alive) {
      return;
    }
    cleanups.forEach((clean) => clean());
    cleanups.clear();
    const proxiesToSubscribe = /* @__PURE__ */ new Set();
    const parent = currentCleanups;
    currentCleanups = cleanups;
    try {
      const promiseOrPossibleCleanup = callback((proxyObject) => {
        proxiesToSubscribe.add(proxyObject);
        if (alive && !subscriptions.has(proxyObject)) {
          const unsubscribe = subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);
          subscriptions.set(proxyObject, unsubscribe);
        }
        return proxyObject;
      });
      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;
      if (couldBeCleanup) {
        if (alive) {
          cleanups.add(couldBeCleanup);
        } else {
          cleanup();
        }
      }
    } finally {
      currentCleanups = parent;
    }
    subscriptions.forEach((unsubscribe, proxyObject) => {
      if (!proxiesToSubscribe.has(proxyObject)) {
        subscriptions.delete(proxyObject);
        unsubscribe();
      }
    });
  };
  if (currentCleanups) {
    currentCleanups.add(cleanup);
  }
  revalidate();
  return cleanup;
}
var DEVTOOLS = Symbol();
function devtools(proxyObject, options) {
  if (typeof options === "string") {
    console.warn(
      "string name option is deprecated, use { name }. https://github.com/pmndrs/valtio/pull/400"
    );
    options = { name: options };
  }
  const { enabled, name = "", ...rest } = options || {};
  let extension;
  try {
    extension = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extension) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && enabled) {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({ name, ...rest });
  const unsub1 = subscribe(proxyObject, (ops) => {
    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(".")}`).join(", ");
    if (!action) {
      return;
    }
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));
      delete snapWithoutDevtools[DEVTOOLS];
      devtools2.send(
        {
          type: action,
          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()
        },
        snapWithoutDevtools
      );
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c, _d, _e, _f;
    if (message.type === "ACTION" && message.payload) {
      try {
        Object.assign(proxyObject, JSON.parse(message.payload));
      } catch (e) {
        console.error(
          "please dispatch a serializable value that JSON.parse() and proxy() support\n",
          e
        );
      }
    }
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
        const state = JSON.parse(message.state);
        Object.assign(proxyObject, state);
      }
      proxyObject[DEVTOOLS] = message;
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({ state }, index) => {
        const action = actions[index] || "No action found";
        Object.assign(proxyObject, state);
        if (index === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2 == null ? void 0 : unsub2();
  };
}
function addComputed_DEPRECATED(proxyObject, computedFns_FAKE, targetObject = proxyObject) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    console.warn(
      "addComputed is deprecated. Please consider using `derive`. Falling back to emulation with derive. https://github.com/pmndrs/valtio/pull/201"
    );
  }
  const derivedFns = {};
  Object.keys(computedFns_FAKE).forEach((key) => {
    derivedFns[key] = (get) => computedFns_FAKE[key](get(proxyObject));
  });
  return f(derivedFns, { proxy: targetObject });
}
function proxyWithComputed_DEPRECATED(initialObject, computedFns) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    console.warn(
      'proxyWithComputed is deprecated. Please follow "Computed Properties" guide in docs.'
    );
  }
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set) {
      desc.set = (newValue) => set(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}
var isObject = (x) => typeof x === "object" && x !== null;
var refSet;
var deepClone = (obj) => {
  if (!refSet) {
    refSet = unstable_buildProxyFunction()[2];
  }
  if (!isObject(obj) || refSet.has(obj)) {
    return obj;
  }
  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));
  Reflect.ownKeys(obj).forEach((key) => {
    baseObject[key] = deepClone(obj[key]);
  });
  return baseObject;
};
function proxyWithHistory_DEPRECATED(initialValue, skipSubscribe = false) {
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    console.warn(
      'proxyWithHistory is deprecated. Please use the "valtio-history" package; refer to the docs'
    );
  }
  const proxyObject = proxy({
    value: initialValue,
    history: ref({
      wip: void 0,
      // to avoid infinite loop
      snapshots: [],
      index: -1
    }),
    clone: deepClone,
    canUndo: () => proxyObject.history.index > 0,
    undo: () => {
      if (proxyObject.canUndo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.clone(
          proxyObject.history.snapshots[--proxyObject.history.index]
        );
      }
    },
    canRedo: () => proxyObject.history.index < proxyObject.history.snapshots.length - 1,
    redo: () => {
      if (proxyObject.canRedo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.clone(
          proxyObject.history.snapshots[++proxyObject.history.index]
        );
      }
    },
    saveHistory: () => {
      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);
      proxyObject.history.snapshots.push(snapshot(proxyObject).value);
      ++proxyObject.history.index;
    },
    subscribe: () => subscribe(proxyObject, (ops) => {
      if (ops.every(
        (op) => op[1][0] === "value" && (op[0] !== "set" || op[2] !== proxyObject.history.wip)
      )) {
        proxyObject.saveHistory();
      }
    })
  });
  proxyObject.saveHistory();
  if (!skipSubscribe) {
    proxyObject.subscribe();
  }
  return proxyObject;
}
function proxySet(initialValues) {
  const set = proxy({
    data: Array.from(new Set(initialValues)),
    has(value) {
      return this.data.indexOf(value) !== -1;
    },
    add(value) {
      let hasProxy = false;
      if (typeof value === "object" && value !== null) {
        hasProxy = this.data.indexOf(proxy(value)) !== -1;
      }
      if (this.data.indexOf(value) === -1 && !hasProxy) {
        this.data.push(value);
      }
      return this;
    },
    delete(value) {
      const index = this.data.indexOf(value);
      if (index === -1) {
        return false;
      }
      this.data.splice(index, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    forEach(cb) {
      this.data.forEach((value) => {
        cb(value, value, this);
      });
    },
    get [Symbol.toStringTag]() {
      return "Set";
    },
    toJSON() {
      return new Set(this.data);
    },
    [Symbol.iterator]() {
      return this.data[Symbol.iterator]();
    },
    values() {
      return this.data.values();
    },
    keys() {
      return this.data.values();
    },
    entries() {
      return new Set(this.data).entries();
    }
  });
  Object.defineProperties(set, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(set);
  return set;
}
function proxyMap(entries) {
  const map = proxy({
    data: Array.from(entries || []),
    has(key) {
      return this.data.some((p) => p[0] === key);
    },
    set(key, value) {
      const record = this.data.find((p) => p[0] === key);
      if (record) {
        record[1] = value;
      } else {
        this.data.push([key, value]);
      }
      return this;
    },
    get(key) {
      var _a;
      return (_a = this.data.find((p) => p[0] === key)) == null ? void 0 : _a[1];
    },
    delete(key) {
      const index = this.data.findIndex((p) => p[0] === key);
      if (index === -1) {
        return false;
      }
      this.data.splice(index, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(cb) {
      this.data.forEach((p) => {
        cb(p[1], p[0], this);
      });
    },
    keys() {
      return this.data.map((p) => p[0]).values();
    },
    values() {
      return this.data.map((p) => p[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  });
  Object.defineProperties(map, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(map);
  return map;
}

// node_modules/valtio/esm/react/utils.mjs
var import_react = __toESM(require_react(), 1);
var DUMMY_SYMBOL = Symbol();
function useProxy(proxy2, options) {
  const snapshot2 = useSnapshot(proxy2, options);
  snapshot2[DUMMY_SYMBOL];
  let isRendering = true;
  (0, import_react.useLayoutEffect)(() => {
    isRendering = false;
  });
  return new Proxy(proxy2, {
    get(target, prop) {
      return isRendering ? snapshot2[prop] : target[prop];
    }
  });
}
export {
  addComputed_DEPRECATED as addComputed,
  f as derive,
  devtools,
  proxyMap,
  proxySet,
  proxyWithComputed_DEPRECATED as proxyWithComputed,
  proxyWithHistory_DEPRECATED as proxyWithHistory,
  subscribeKey,
  u as underive,
  i as unstable_deriveSubscriptions,
  useProxy,
  watch
};
//# sourceMappingURL=valtio_utils.js.map
